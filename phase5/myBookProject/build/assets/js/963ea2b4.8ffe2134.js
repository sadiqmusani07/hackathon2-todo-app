"use strict";(self.webpackChunkmybookproject=self.webpackChunkmybookproject||[]).push([[4929],{1690(n,e,i){i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>t,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-2/physics-simulation-gazebo","title":"Chapter 1: Physics Simulation in Gazebo","description":"Learn to create realistic physics simulations in Gazebo for humanoid robotics","source":"@site/docs/module-2/01-physics-simulation-gazebo.md","sourceDirName":"module-2","slug":"/module-2/physics-simulation-gazebo","permalink":"/docs/module-2/physics-simulation-gazebo","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Chapter 1: Physics Simulation in Gazebo","description":"Learn to create realistic physics simulations in Gazebo for humanoid robotics"},"sidebar":"tutorialSidebar","previous":{"title":"Module 1, Chapter 3: Humanoid Modeling with URDF","permalink":"/docs/module-1/urdf-modeling"},"next":{"title":"Chapter 2: High-Fidelity Rendering in Unity","permalink":"/docs/module-2/high-fidelity-rendering-unity"}}');var a=i(4848),r=i(8453);const o={sidebar_position:1,title:"Chapter 1: Physics Simulation in Gazebo",description:"Learn to create realistic physics simulations in Gazebo for humanoid robotics"},t="Chapter 1: Physics Simulation in Gazebo",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Setting Up Gazebo Physics Environment",id:"setting-up-gazebo-physics-environment",level:2},{value:"Installing Gazebo",id:"installing-gazebo",level:3},{value:"Basic Physics Configuration",id:"basic-physics-configuration",level:3},{value:"Creating Your First Physics World",id:"creating-your-first-physics-world",level:3},{value:"Gravity and Collision Setup",id:"gravity-and-collision-setup",level:2},{value:"Understanding Gravity in Gazebo",id:"understanding-gravity-in-gazebo",level:3},{value:"Collision Properties",id:"collision-properties",level:3},{value:"Robot and Environment Configuration",id:"robot-and-environment-configuration",level:2},{value:"Adding a Simple Robot",id:"adding-a-simple-robot",level:3},{value:"Environment Objects",id:"environment-objects",level:3},{value:"Sensor Simulation",id:"sensor-simulation",level:2},{value:"LiDAR Simulation",id:"lidar-simulation",level:3},{value:"IMU Simulation",id:"imu-simulation",level:3},{value:"Depth Camera Simulation",id:"depth-camera-simulation",level:3},{value:"Physics Parameter Tuning",id:"physics-parameter-tuning",level:2},{value:"Understanding Time Steps",id:"understanding-time-steps",level:3},{value:"Tuning for Stability",id:"tuning-for-stability",level:3},{value:"Performance vs Accuracy Trade-offs",id:"performance-vs-accuracy-trade-offs",level:3},{value:"Running Your Simulation",id:"running-your-simulation",level:2},{value:"Launching Gazebo with Your World",id:"launching-gazebo-with-your-world",level:3},{value:"Connecting to ROS 2",id:"connecting-to-ros-2",level:3},{value:"Summary",id:"summary",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"chapter-1-physics-simulation-in-gazebo",children:"Chapter 1: Physics Simulation in Gazebo"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.img,{alt:"Gazebo Simulation",src:i(5263).A+"",width:"800",height:"400"})}),"\n",(0,a.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(e.p,{children:"Gazebo is a powerful physics simulation environment that provides realistic simulation of robots and their environments. In this chapter, you'll learn how to set up physics simulations with realistic gravity, collisions, and dynamics for humanoid robots."}),"\n",(0,a.jsx)(e.h2,{id:"setting-up-gazebo-physics-environment",children:"Setting Up Gazebo Physics Environment"}),"\n",(0,a.jsx)(e.h3,{id:"installing-gazebo",children:"Installing Gazebo"}),"\n",(0,a.jsx)(e.p,{children:"Before we begin, ensure you have Gazebo Garden or later installed. For ROS 2 Humble Hawksbill users, you can install the ROS 2 Gazebo packages:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:"sudo apt update\nsudo apt install ros-humble-gazebo-ros-pkgs ros-humble-gazebo-plugins ros-humble-gazebo-dev\n"})}),"\n",(0,a.jsx)(e.h3,{id:"basic-physics-configuration",children:"Basic Physics Configuration"}),"\n",(0,a.jsx)(e.p,{children:"Gazebo uses the Ignition Physics engine to simulate realistic physics. The core physics parameters include:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Gravity"}),": Typically set to -9.8 m/s\xb2 in the Z direction (downward)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Damping"}),": Reduces velocity over time to simulate friction"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Real-time factor"}),": Controls simulation speed relative to real time"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"creating-your-first-physics-world",children:"Creating Your First Physics World"}),"\n",(0,a.jsx)(e.p,{children:"Let's start by creating a basic world file with physics properties:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="digital_twin_world">\n    \x3c!-- Physics engine configuration --\x3e\n    <physics type="ignition-physics_6_0">\n      <gravity>0 0 -9.8</gravity>\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n    </physics>\n\n    \x3c!-- Include a ground plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Include a sky --\x3e\n    <include>\n      <uri>model://sun</uri>\n    </include>\n  </world>\n</sdf>\n'})}),"\n",(0,a.jsxs)(e.p,{children:["Save this as ",(0,a.jsx)(e.code,{children:"digital_twin_world.sdf"})," in your Gazebo models directory."]}),"\n",(0,a.jsx)(e.h2,{id:"gravity-and-collision-setup",children:"Gravity and Collision Setup"}),"\n",(0,a.jsx)(e.h3,{id:"understanding-gravity-in-gazebo",children:"Understanding Gravity in Gazebo"}),"\n",(0,a.jsxs)(e.p,{children:["Gravity in Gazebo is defined as a 3D vector that affects all objects in the simulation. The default value of ",(0,a.jsx)(e.code,{children:"0 0 -9.8"})," means gravity pulls objects downward at 9.8 m/s\xb2:"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"X: 0 (no horizontal gravity)"}),"\n",(0,a.jsx)(e.li,{children:"Y: 0 (no horizontal gravity)"}),"\n",(0,a.jsx)(e.li,{children:"Z: -9.8 (downward gravity)"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"collision-properties",children:"Collision Properties"}),"\n",(0,a.jsx)(e.p,{children:"Each object in Gazebo has collision properties that define how it interacts with other objects:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<collision name="collision">\n  <geometry>\n    <box>\n      <size>1.0 1.0 1.0</size>\n    </box>\n  </geometry>\n  <surface>\n    <friction>\n      <ode>\n        <mu>1.0</mu>\n        <mu2>1.0</mu2>\n      </ode>\n    </friction>\n    <bounce>\n      <restitution_coefficient>0.1</restitution_coefficient>\n      <threshold>100000</threshold>\n    </bounce>\n  </surface>\n</collision>\n'})}),"\n",(0,a.jsx)(e.p,{children:"Key parameters:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"mu"}),": Primary friction coefficient"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"mu2"}),": Secondary friction coefficient"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"restitution_coefficient"}),": Bounciness (0 = no bounce, 1 = perfectly elastic)"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"robot-and-environment-configuration",children:"Robot and Environment Configuration"}),"\n",(0,a.jsx)(e.h3,{id:"adding-a-simple-robot",children:"Adding a Simple Robot"}),"\n",(0,a.jsx)(e.p,{children:"Let's create a simple robot model with proper physics properties:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<model name="simple_robot">\n  <pose>0 0 0.5 0 0 0</pose>\n  <link name="chassis">\n    <pose>0 0 0.1 0 0 0</pose>\n    <collision name="collision">\n      <geometry>\n        <box>\n          <size>0.5 0.3 0.2</size>\n        </box>\n      </geometry>\n    </collision>\n    <visual name="visual">\n      <geometry>\n        <box>\n          <size>0.5 0.3 0.2</size>\n        </box>\n      </geometry>\n    </visual>\n    <inertial>\n      <mass>1.0</mass>\n      <inertia>\n        <ixx>0.01</ixx>\n        <ixy>0</ixy>\n        <ixz>0</ixz>\n        <iyy>0.01</iyy>\n        <iyz>0</iyz>\n        <izz>0.01</izz>\n      </inertia>\n    </inertial>\n  </link>\n</model>\n'})}),"\n",(0,a.jsx)(e.h3,{id:"environment-objects",children:"Environment Objects"}),"\n",(0,a.jsx)(e.p,{children:"You can add various environment objects to test your robot:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Add a box obstacle --\x3e\n<model name="obstacle_box">\n  <pose>2 0 0.5 0 0 0</pose>\n  <link name="link">\n    <collision name="collision">\n      <geometry>\n        <box>\n          <size>0.5 0.5 0.5</size>\n        </box>\n      </geometry>\n    </collision>\n    <visual name="visual">\n      <geometry>\n        <box>\n          <size>0.5 0.5 0.5</size>\n        </box>\n      </geometry>\n    </visual>\n    <inertial>\n      <mass>5.0</mass>\n      <inertia>\n        <ixx>0.208</ixx>\n        <ixy>0</ixy>\n        <ixz>0</ixz>\n        <iyy>0.208</iyy>\n        <iyz>0</iyz>\n        <izz>0.208</izz>\n      </inertia>\n    </inertial>\n  </link>\n</model>\n'})}),"\n",(0,a.jsx)(e.h2,{id:"sensor-simulation",children:"Sensor Simulation"}),"\n",(0,a.jsx)(e.h3,{id:"lidar-simulation",children:"LiDAR Simulation"}),"\n",(0,a.jsx)(e.p,{children:"Gazebo can simulate various sensors including LiDAR:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<sensor name="lidar" type="ray">\n  <pose>0.2 0 0.1 0 0 0</pose>\n  <ray>\n    <scan>\n      <horizontal>\n        <samples>360</samples>\n        <resolution>1</resolution>\n        <min_angle>-3.14159</min_angle>\n        <max_angle>3.14159</max_angle>\n      </horizontal>\n    </scan>\n    <range>\n      <min>0.1</min>\n      <max>10.0</max>\n      <resolution>0.01</resolution>\n    </range>\n  </ray>\n  <plugin name="lidar_controller" filename="libgazebo_ros_ray_sensor.so">\n    <ros>\n      <namespace>lidar</namespace>\n      <remapping>~/out:=scan</remapping>\n    </ros>\n    <output_type>sensor_msgs/LaserScan</output_type>\n  </plugin>\n</sensor>\n'})}),"\n",(0,a.jsx)(e.h3,{id:"imu-simulation",children:"IMU Simulation"}),"\n",(0,a.jsx)(e.p,{children:"Simulate an Inertial Measurement Unit (IMU):"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<sensor name="imu_sensor" type="imu">\n  <always_on>true</always_on>\n  <update_rate>100</update_rate>\n  <pose>0 0 0 0 0 0</pose>\n  <plugin name="imu_plugin" filename="libgazebo_ros_imu.so">\n    <ros>\n      <namespace>imu</namespace>\n      <remapping>~/out:=data</remapping>\n    </ros>\n    <initial_orientation_as_reference>false</initial_orientation_as_reference>\n  </plugin>\n</sensor>\n'})}),"\n",(0,a.jsx)(e.h3,{id:"depth-camera-simulation",children:"Depth Camera Simulation"}),"\n",(0,a.jsx)(e.p,{children:"Simulate a depth camera for 3D perception:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<sensor name="depth_camera" type="depth">\n  <pose>0.1 0 0.1 0 0 0</pose>\n  <camera>\n    <horizontal_fov>1.047</horizontal_fov>\n    <image>\n      <width>640</width>\n      <height>480</height>\n      <format>R8G8B8</format>\n    </image>\n    <clip>\n      <near>0.1</near>\n      <far>10</far>\n    </clip>\n  </camera>\n  <always_on>true</always_on>\n  <update_rate>30</update_rate>\n  <visualize>true</visualize>\n  <plugin name="camera_controller" filename="libgazebo_ros_openni_kinect.so">\n    <ros>\n      <namespace>camera</namespace>\n      <remapping>~/depth/image_raw:=depth/image_raw</remapping>\n      <remapping>~/rgb/image_raw:=rgb/image_raw</remapping>\n    </ros>\n    <output_type>sensor_msgs/PointCloud2</output_type>\n  </plugin>\n</sensor>\n'})}),"\n",(0,a.jsx)(e.h2,{id:"physics-parameter-tuning",children:"Physics Parameter Tuning"}),"\n",(0,a.jsx)(e.h3,{id:"understanding-time-steps",children:"Understanding Time Steps"}),"\n",(0,a.jsx)(e.p,{children:"The physics simulation runs in discrete time steps. Key parameters:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"max_step_size"}),": The largest time step the simulator will take (typically 0.001s)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"real_time_update_rate"}),": How many simulation steps per real second"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"real_time_factor"}),": Desired speed of simulation vs real time (1.0 = real-time)"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"tuning-for-stability",children:"Tuning for Stability"}),"\n",(0,a.jsx)(e.p,{children:"For stable simulation:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Smaller time steps"}),": More accurate but slower simulation"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Appropriate mass and inertia"}),": Realistic values for stable physics"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Collision properties"}),": Proper friction and bounce values"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"performance-vs-accuracy-trade-offs",children:"Performance vs Accuracy Trade-offs"}),"\n",(0,a.jsx)(e.p,{children:"For educational purposes, balance these settings:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<physics type="ignition-physics_6_0">\n  <gravity>0 0 -9.8</gravity>\n  <max_step_size>0.001</max_step_size>  \x3c!-- Smaller for accuracy --\x3e\n  <real_time_factor>0.5</real_time_factor>  \x3c!-- Slower for stability --\x3e\n  <real_time_update_rate>1000</real_time_update_rate>\n</physics>\n'})}),"\n",(0,a.jsx)(e.h2,{id:"running-your-simulation",children:"Running Your Simulation"}),"\n",(0,a.jsx)(e.h3,{id:"launching-gazebo-with-your-world",children:"Launching Gazebo with Your World"}),"\n",(0,a.jsx)(e.p,{children:"Create a launch file to easily start your simulation:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"# launch/digital_twin_sim.launch.py\nfrom launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import PathJoinSubstitution\nfrom launch_ros.substitutions import FindPackageShare\nfrom launch.actions import ExecuteProcess\n\ndef generate_launch_description():\n    world_path = PathJoinSubstitution([\n        FindPackageShare('your_robot_description'),\n        'worlds',\n        'digital_twin_world.sdf'\n    ])\n\n    gzserver = ExecuteProcess(\n        cmd=['gzserver', '--verbose', world_path],\n        output='screen'\n    )\n\n    gzclient = ExecuteProcess(\n        cmd=['gzclient', '--verbose'],\n        output='screen'\n    )\n\n    return LaunchDescription([\n        gzserver,\n        gzclient\n    ])\n"})}),"\n",(0,a.jsx)(e.h3,{id:"connecting-to-ros-2",children:"Connecting to ROS 2"}),"\n",(0,a.jsx)(e.p,{children:"Once your simulation is running, you can connect ROS 2 nodes to interact with it:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:"# Check available topics\nros2 topic list\n\n# View sensor data\nros2 topic echo /lidar/scan sensor_msgs/msg/LaserScan\nros2 topic echo /imu/data sensor_msgs/msg/Imu\n"})}),"\n",(0,a.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(e.p,{children:"In this chapter, you've learned how to:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Set up a Gazebo physics environment with realistic parameters"}),"\n",(0,a.jsx)(e.li,{children:"Configure gravity, collision properties, and dynamics"}),"\n",(0,a.jsx)(e.li,{children:"Add robot models and environment objects"}),"\n",(0,a.jsx)(e.li,{children:"Simulate various sensors (LiDAR, IMU, depth camera)"}),"\n",(0,a.jsx)(e.li,{children:"Tune physics parameters for stability and performance"}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:["In the ",(0,a.jsx)(e.a,{href:"./02-high-fidelity-rendering-unity",children:"next chapter"}),", we'll explore how to create high-fidelity visualizations in Unity that match these physics simulations."]})]})}function u(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},5263(n,e,i){i.d(e,{A:()=>s});const s="data:image/jpeg;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI4MDAiIGhlaWdodD0iNDAwIiB2aWV3Qm94PSIwIDAgODAwIDQwMCI+CiAgPHJlY3Qgd2lkdGg9IjgwMCIgaGVpZ2h0PSI0MDAiIGZpbGw9IiNmMGY4ZmYiLz4KICA8cmVjdCB4PSIzMDAiIHk9IjEwMCIgd2lkdGg9IjIwMCIgaGVpZ2h0PSIyMDAiIGZpbGw9IiM0NjgyYjQiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSIyIi8+CiAgPGNpcmNsZSBjeD0iMzUwIiBjeT0iMTUwIiByPSIyMCIgZmlsbD0iI2ZmZiIgc3Ryb2tlPSIjMDAwIiBzdHJva2Utd2lkdGg9IjIiLz4KICA8Y2lyY2xlIGN4PSI0NTAiIGN5PSIxNTAiIHI9IjIwIiBmaWxsPSIjZmZmIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMiIvPgogIDxyZWN0IHg9IjMyNSIgeT0iMjIwIiB3aWR0aD0iMTUwIiBoZWlnaHQ9IjUwIiBmaWxsPSIjNTU2YjJmIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMiIvPgogIDx0ZXh0IHg9IjQwMCIgeT0iMzIwIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiMzMzMiIHRleHQtYW5jaG9yPSJtaWRkbGUiPlJPUyAyIFJvYm90PC90ZXh0Pgo8L3N2Zz4="},8453(n,e,i){i.d(e,{R:()=>o,x:()=>t});var s=i(6540);const a={},r=s.createContext(a);function o(n){const e=s.useContext(r);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function t(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:o(n.components),s.createElement(r.Provider,{value:e},n.children)}}}]);