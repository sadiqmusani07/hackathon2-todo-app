"use strict";(self.webpackChunkmybookproject=self.webpackChunkmybookproject||[]).push([[4338],{3950(e,n,a){a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-3/nav2-path-planning","title":"Module 3, Chapter 3: Path Planning with Nav2","description":"Learn to implement path planning using Nav2 specifically adapted for bipedal humanoid movement patterns and constraints","source":"@site/docs/module-3/03-nav2-path-planning.md","sourceDirName":"module-3","slug":"/module-3/nav2-path-planning","permalink":"/docs/module-3/nav2-path-planning","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Module 3, Chapter 3: Path Planning with Nav2","description":"Learn to implement path planning using Nav2 specifically adapted for bipedal humanoid movement patterns and constraints"},"sidebar":"tutorialSidebar","previous":{"title":"Module 3, Chapter 2: Isaac ROS for Perception and Navigation","permalink":"/docs/module-3/isaac-ros-perception-navigation"},"next":{"title":"Module 4, Chapter 1: Voice-to-Action with Speech Recognition","permalink":"/docs/module-4/voice-to-action"}}');var o=a(4848),i=a(8453);const s={sidebar_position:3,title:"Module 3, Chapter 3: Path Planning with Nav2",description:"Learn to implement path planning using Nav2 specifically adapted for bipedal humanoid movement patterns and constraints"},r="Module 3, Chapter 3: Path Planning with Nav2",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Nav2 Overview for Bipedal Humanoid Movement",id:"nav2-overview-for-bipedal-humanoid-movement",level:2},{value:"Introduction to Navigation2",id:"introduction-to-navigation2",level:3},{value:"Nav2 Architecture for Humanoid Robots",id:"nav2-architecture-for-humanoid-robots",level:3},{value:"Humanoid-Specific Navigation Challenges",id:"humanoid-specific-navigation-challenges",level:3},{value:"Nav2 Components for Humanoid Navigation",id:"nav2-components-for-humanoid-navigation",level:3},{value:"Motion Planning Algorithms for Humanoid Robots",id:"motion-planning-algorithms-for-humanoid-robots",level:2},{value:"Overview of Motion Planning Approaches",id:"overview-of-motion-planning-approaches",level:3},{value:"Humanoid-Specific Path Planning",id:"humanoid-specific-path-planning",level:3},{value:"Gait Pattern Planning",id:"gait-pattern-planning",level:3},{value:"Obstacle Avoidance and Trajectory Control",id:"obstacle-avoidance-and-trajectory-control",level:2},{value:"Dynamic Obstacle Avoidance",id:"dynamic-obstacle-avoidance",level:3},{value:"Trajectory Control for Humanoid Locomotion",id:"trajectory-control-for-humanoid-locomotion",level:3},{value:"Preparing for Autonomous Tasks with Safety Measures",id:"preparing-for-autonomous-tasks-with-safety-measures",level:2},{value:"Humanoid Navigation Safety Framework",id:"humanoid-navigation-safety-framework",level:3},{value:"Autonomous Task Preparation",id:"autonomous-task-preparation",level:3},{value:"Practical Exercise: Complete Navigation System",id:"practical-exercise-complete-navigation-system",level:2},{value:"Summary",id:"summary",level:2},{value:"Navigation",id:"navigation",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"module-3-chapter-3-path-planning-with-nav2",children:"Module 3, Chapter 3: Path Planning with Nav2"})}),"\n",(0,o.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(n.p,{children:"Navigation2 (Nav2) is the premier navigation framework for ROS 2, providing advanced path planning capabilities. This chapter focuses on adapting Nav2 specifically for bipedal humanoid movement patterns and constraints, covering motion planning algorithms, obstacle avoidance, and trajectory control techniques for safe humanoid navigation."}),"\n",(0,o.jsx)(n.h2,{id:"nav2-overview-for-bipedal-humanoid-movement",children:"Nav2 Overview for Bipedal Humanoid Movement"}),"\n",(0,o.jsx)(n.h3,{id:"introduction-to-navigation2",children:"Introduction to Navigation2"}),"\n",(0,o.jsx)(n.p,{children:"Navigation2 is the successor to ROS Navigation stack, redesigned for ROS 2 with improved flexibility and performance. For humanoid robots, Nav2 provides:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Modular Architecture"}),": Pluggable components for customization"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Behavior Trees"}),": Declarative navigation behavior specification"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Advanced Algorithms"}),": State-of-the-art motion planning"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Safety Features"}),": Built-in obstacle avoidance and recovery"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"nav2-architecture-for-humanoid-robots",children:"Nav2 Architecture for Humanoid Robots"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"# Example: Nav2 architecture for humanoid robots\nfrom nav2_behavior_tree import bt_builder\nfrom nav2_msgs.action import NavigateToPose\nfrom geometry_msgs.msg import PoseStamped, Twist\nfrom nav_msgs.msg import Path, OccupancyGrid\nimport rclpy\nfrom rclpy.action import ActionClient\nfrom rclpy.node import Node\n\nclass HumanoidNav2Manager(Node):\n    def __init__(self):\n        super().__init__('humanoid_nav2_manager')\n\n        # Nav2 action clients\n        self.nav_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')\n\n        # Publishers for humanoid-specific navigation\n        self.local_plan_pub = self.create_publisher(Path, '/humanoid/local_plan', 10)\n        self.global_plan_pub = self.create_publisher(Path, '/humanoid/global_plan', 10)\n        self.velocity_pub = self.create_publisher(Twist, '/humanoid/cmd_vel', 10)\n\n        # Humanoid-specific parameters\n        self.humanoid_config = {\n            'step_length': 0.4,  # Max step length for humanoid\n            'turn_radius': 0.3,  # Minimum turning radius\n            'foot_separation': 0.2,  # Distance between feet\n            'balance_margin': 0.1,  # Safety margin for balance\n            'max_step_height': 0.1  # Max step-over height\n        }\n\n    def create_humanoid_navigate_request(self, goal_pose):\n        # Create navigation request adapted for humanoid movement\n        goal_msg = NavigateToPose.Goal()\n        goal_msg.pose = goal_pose\n        goal_msg.behavior_tree_id = 'humanoid_navigate_bt'  # Custom BT for humanoid\n\n        return goal_msg\n"})}),"\n",(0,o.jsx)(n.h3,{id:"humanoid-specific-navigation-challenges",children:"Humanoid-Specific Navigation Challenges"}),"\n",(0,o.jsx)(n.p,{children:"Humanoid robots face unique navigation challenges compared to wheeled robots:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Balance Constraints"}),": Maintaining center of mass within support polygon"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Step Planning"}),": Discrete foot placement rather than continuous motion"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Stability Requirements"}),": Need for stable gait patterns"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Obstacle Clearance"}),": Ensuring sufficient clearance for legs and arms"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Dynamic Balance"}),": Managing momentum during movement"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"nav2-components-for-humanoid-navigation",children:"Nav2 Components for Humanoid Navigation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"# Example: Humanoid-specific Nav2 components\nfrom nav2_core import Planner, Controller, Costmap\nfrom nav2_util.lifecycle_node import LifecycleNode\nfrom geometry_msgs.msg import Point\n\nclass HumanoidPathPlanner(LifecycleNode):\n    def __init__(self):\n        super().__init__('humanoid_path_planner')\n\n    def configure(self, plugin_name, costmap_ros, lifecycle_node, planner_node):\n        # Configure for humanoid-specific planning\n        self.costmap = costmap_ros.get_costmap()\n        self.plugin_name = plugin_name\n\n        # Humanoid-specific parameters\n        self.step_length = lifecycle_node.get_parameter(\n            'step_length').value\n        self.turn_radius = lifecycle_node.get_parameter(\n            'turn_radius').value\n        self.balance_margin = lifecycle_node.get_parameter(\n            'balance_margin').value\n\n    def create_plan(self, start, goal):\n        # Plan path considering humanoid kinematic constraints\n        # This would implement humanoid-specific path planning algorithms\n        humanoid_path = self.plan_humanoid_path(start, goal)\n\n        # Convert to standard Path message\n        path_msg = Path()\n        path_msg.header.frame_id = 'map'\n        path_msg.poses = humanoid_path\n\n        return path_msg\n\n    def plan_humanoid_path(self, start, goal):\n        # Implementation of humanoid-aware path planning\n        # Consider step constraints, balance polygons, etc.\n        planned_path = []\n\n        # Simplified example using RRT for humanoid path planning\n        current = start\n        while self.distance(current, goal) > 0.5:  # 50cm tolerance\n            # Find next valid step position\n            next_waypoint = self.find_next_humanoid_step(current, goal)\n            planned_path.append(next_waypoint)\n            current = next_waypoint\n\n            if len(planned_path) > 1000:  # Prevent infinite loops\n                self.get_logger().warn(\"Path planning exceeded max iterations\")\n                break\n\n        return planned_path\n\n    def find_next_humanoid_step(self, current, goal):\n        # Find next valid position for humanoid foot placement\n        # considering balance and obstacle constraints\n        direction = self.normalize_vector(\n            [goal.pose.position.x - current.pose.position.x,\n             goal.pose.position.y - current.pose.position.y]\n        )\n\n        # Calculate next step position\n        step_x = current.pose.position.x + direction[0] * self.step_length\n        step_y = current.pose.position.y + direction[1] * self.step_length\n\n        # Check for balance polygon constraints\n        next_pose = PoseStamped()\n        next_pose.pose.position.x = step_x\n        next_pose.pose.position.y = step_y\n        next_pose.pose.position.z = 0.0\n\n        # Check if this step is safe and balanced\n        if self.is_safe_for_humanoid(next_pose):\n            return next_pose\n        else:\n            # Find alternative step using local planning\n            return self.find_alternative_step(current, goal)\n"})}),"\n",(0,o.jsx)(n.h2,{id:"motion-planning-algorithms-for-humanoid-robots",children:"Motion Planning Algorithms for Humanoid Robots"}),"\n",(0,o.jsx)(n.h3,{id:"overview-of-motion-planning-approaches",children:"Overview of Motion Planning Approaches"}),"\n",(0,o.jsx)(n.p,{children:"Different algorithms have varying suitability for humanoid navigation:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["*",(0,o.jsx)(n.em,{children:"A"})," (A-star)**: Good for static environments, optimal paths"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Dijkstra"}),": Optimal but computationally expensive"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"RRT (Rapidly-exploring Random Tree)"}),": Good for high-dimensional spaces"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"TEB (Timed Elastic Band)"}),": Real-time optimization for dynamic environments"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Footstep Planning"}),": Specific to legged robots"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"humanoid-specific-path-planning",children:"Humanoid-Specific Path Planning"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'# Example: Humanoid-aware path planning algorithm\nimport numpy as np\nfrom scipy.spatial import KDTree\nimport math\n\nclass HumanoidMotionPlanner:\n    def __init__(self):\n        self.step_length = 0.4  # meters\n        self.turn_radius = 0.3  # meters\n        self.balance_margin = 0.1  # meters\n        self.max_step_height = 0.1  # meters\n\n    def plan_footsteps(self, start_pose, goal_pose, costmap):\n        # Plan sequence of footstep positions for humanoid\n        footsteps = [start_pose]\n\n        current_pose = start_pose\n        step_count = 0\n        max_steps = 100  # Prevent infinite planning\n\n        while self.distance(current_pose, goal_pose) > self.step_length and step_count < max_steps:\n            # Find next valid footstep position\n            next_step = self.find_next_footstep(current_pose, goal_pose, costmap)\n\n            if next_step is None:\n                # Try recovery behavior\n                next_step = self.find_alternative_path(current_pose, goal_pose, costmap)\n\n            if next_step is not None:\n                footsteps.append(next_step)\n                current_pose = next_step\n            else:\n                # Could not find valid step\n                self.get_logger().warn("Could not find valid footstep")\n                return None\n\n            step_count += 1\n\n        # Add final step to goal if close enough\n        if self.distance(current_pose, goal_pose) <= self.step_length:\n            footsteps.append(goal_pose)\n\n        return footsteps\n\n    def find_next_footstep(self, current_pose, goal_pose, costmap):\n        # Find next footstep considering humanoid constraints\n        candidate_positions = self.generate_step_candidates(current_pose, goal_pose)\n\n        for candidate in candidate_positions:\n            if self.is_valid_footstep(candidate, costmap):\n                return candidate\n\n        return None\n\n    def generate_step_candidates(self, current_pose, goal_direction):\n        # Generate potential footstep positions\n        candidates = []\n\n        # Primary direction toward goal\n        goal_dir = self.normalize_vector([\n            goal_direction.pose.position.x - current_pose.pose.position.x,\n            goal_direction.pose.position.y - current_pose.pose.position.y\n        ])\n\n        # Forward step\n        forward_pos = self.add_vector_to_pose(\n            current_pose,\n            [goal_dir[0] * self.step_length, goal_dir[1] * self.step_length, 0]\n        )\n        candidates.append(forward_pos)\n\n        # Lateral steps (left and right)\n        left_dir = [-goal_dir[1], goal_dir[0]]  # Rotate 90 degrees left\n        right_dir = [goal_dir[1], -goal_dir[0]]  # Rotate 90 degrees right\n\n        left_pos = self.add_vector_to_pose(\n            current_pose,\n            [left_dir[0] * self.step_length * 0.7, left_dir[1] * self.step_length * 0.7, 0]\n        )\n        right_pos = self.add_vector_to_pose(\n            current_pose,\n            [right_dir[0] * self.step_length * 0.7, right_dir[1] * self.step_length * 0.7, 0]\n        )\n\n        candidates.extend([left_pos, right_pos])\n\n        # Diagonal steps\n        diag_left = self.add_vector_to_pose(\n            current_pose,\n            [(goal_dir[0] + left_dir[0]) * self.step_length * 0.7,\n             (goal_dir[1] + left_dir[1]) * self.step_length * 0.7, 0]\n        )\n        diag_right = self.add_vector_to_pose(\n            current_pose,\n            [(goal_dir[0] + right_dir[0]) * self.step_length * 0.7,\n             (goal_dir[1] + right_dir[1]) * self.step_length * 0.7, 0]\n        )\n\n        candidates.extend([diag_left, diag_right])\n\n        return candidates\n\n    def is_valid_footstep(self, pose, costmap):\n        # Check if footstep is valid considering:\n        # - Collision with obstacles\n        # - Balance constraints\n        # - Terrain traversability\n        # - Step height constraints\n\n        # Convert pose to costmap coordinates\n        mx, my = self.world_to_map(pose.pose.position.x, pose.pose.position.y, costmap)\n\n        # Check costmap for collisions\n        if not (0 <= mx < costmap.metadata.size_x and 0 <= my < costmap.metadata.size_y):\n            return False  # Outside map bounds\n\n        cost = costmap.data[my * costmap.metadata.size_x + mx]\n        if cost >= 253:  # lethal obstacle\n            return False\n\n        # Additional checks for humanoid-specific constraints\n        if cost > 100:  # consider as invalid if too costly\n            return False\n\n        # Check for step height (simplified)\n        terrain_height = self.get_terrain_height_at(pose)\n        if abs(terrain_height) > self.max_step_height:\n            return False\n\n        return True\n'})}),"\n",(0,o.jsx)(n.h3,{id:"gait-pattern-planning",children:"Gait Pattern Planning"}),"\n",(0,o.jsx)(n.p,{children:"Humanoid robots need to plan gait patterns in addition to paths:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"# Example: Gait pattern planning\nclass GaitPatternPlanner:\n    def __init__(self):\n        self.stride_length = 0.4  # Distance between consecutive footfalls\n        self.step_width = 0.2     # Distance between left and right footprints\n        self.step_height = 0.05   # Height of foot lift during stepping\n        self.step_duration = 0.8  # Time for each step (seconds)\n\n    def plan_gait_pattern(self, footsteps):\n        # Plan gait timing and coordination for footsteps\n        gait_sequence = []\n\n        for i, step in enumerate(footsteps[:-1]):  # Skip last step (final pose)\n            # Determine which foot makes this step\n            support_foot = 'left' if i % 2 == 0 else 'right'\n            swing_foot = 'right' if i % 2 == 0 else 'left'\n\n            # Plan step trajectory\n            step_trajectory = self.plan_step_trajectory(\n                step, footsteps[i+1], swing_foot, self.step_duration\n            )\n\n            gait_sequence.append({\n                'step_index': i,\n                'swing_foot': swing_foot,\n                'support_foot': support_foot,\n                'trajectory': step_trajectory,\n                'start_time': i * self.step_duration,\n                'end_time': (i + 1) * self.step_duration\n            })\n\n        return gait_sequence\n\n    def plan_step_trajectory(self, start_pose, end_pose, foot, duration):\n        # Plan 3D trajectory for a single step\n        # This would include lift, swing, and placement phases\n\n        trajectory_points = []\n        num_points = int(duration * 50)  # 50Hz trajectory generation\n\n        for i in range(num_points + 1):\n            t = i / num_points  # Normalized time (0 to 1)\n\n            # Interpolate position\n            x = start_pose.pose.position.x + t * (\n                end_pose.pose.position.x - start_pose.pose.position.x\n            )\n            y = start_pose.pose.position.y + t * (\n                end_pose.pose.position.y - start_pose.pose.position.y\n            )\n\n            # Add parabolic lift for foot\n            lift_factor = 4 * t * (1 - t)  # Parabolic curve\n            z = start_pose.pose.position.z + lift_factor * self.step_height\n\n            # Create trajectory point\n            traj_point = {\n                'position': (x, y, z),\n                'time_from_start': rclpy.duration.Duration(seconds=t * duration)\n            }\n            trajectory_points.append(traj_point)\n\n        return trajectory_points\n"})}),"\n",(0,o.jsx)(n.h2,{id:"obstacle-avoidance-and-trajectory-control",children:"Obstacle Avoidance and Trajectory Control"}),"\n",(0,o.jsx)(n.h3,{id:"dynamic-obstacle-avoidance",children:"Dynamic Obstacle Avoidance"}),"\n",(0,o.jsx)(n.p,{children:"Humanoid robots need to handle both static and dynamic obstacles:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"# Example: Humanoid obstacle avoidance\nfrom geometry_msgs.msg import Point, Vector3\nfrom visualization_msgs.msg import Marker\n\nclass HumanoidObstacleAvoider:\n    def __init__(self, node):\n        self.node = node\n        self.obstacles = []  # List of detected obstacles\n        self.humanoid_radius = 0.3  # Effective radius for collision checking\n        self.avoidance_distance = 0.5  # Minimum safe distance\n\n        # Publishers for visualization\n        self.obstacle_marker_pub = self.node.create_publisher(\n            Marker, '/humanoid/obstacles', 10\n        )\n\n    def update_obstacles(self, detection_msg):\n        # Update list of detected obstacles\n        self.obstacles = detection_msg.obstacles\n\n    def compute_avoidance_velocity(self, current_pose, current_velocity, goal):\n        # Compute avoidance velocity using artificial potential fields\n        repulsive_force = self.calculate_repulsive_force(current_pose)\n        attractive_force = self.calculate_attractive_force(current_pose, goal)\n\n        # Combine forces\n        total_force = self.combine_forces(attractive_force, repulsive_force)\n\n        # Convert to desired velocity\n        desired_velocity = self.force_to_velocity(total_force, current_velocity)\n\n        # Ensure humanoid kinematic constraints are satisfied\n        constrained_velocity = self.apply_humanoid_constraints(desired_velocity)\n\n        return constrained_velocity\n\n    def calculate_repulsive_force(self, current_pose):\n        # Calculate repulsive force from all obstacles\n        total_force = np.array([0.0, 0.0])\n\n        for obstacle in self.obstacles:\n            # Calculate distance and direction to obstacle\n            dx = obstacle.pose.position.x - current_pose.pose.position.x\n            dy = obstacle.pose.position.y - current_pose.pose.position.y\n            distance = math.sqrt(dx*dx + dy*dy)\n\n            if distance < self.avoidance_distance:\n                # Normalize direction away from obstacle\n                if distance > 0.01:  # Avoid division by zero\n                    dir_x = -dx / distance\n                    dir_y = -dy / distance\n                else:\n                    # Random direction if too close\n                    angle = np.random.uniform(0, 2*np.pi)\n                    dir_x = np.cos(angle)\n                    dir_y = np.sin(angle)\n\n                # Calculate force magnitude (stronger when closer)\n                force_magnitude = (1.0/distance - 1.0/self.avoidance_distance) * 5.0\n                total_force[0] += dir_x * force_magnitude\n                total_force[1] += dir_y * force_magnitude\n\n        return total_force\n\n    def calculate_attractive_force(self, current_pose, goal):\n        # Calculate attractive force toward goal\n        dx = goal.pose.position.x - current_pose.pose.position.x\n        dy = goal.pose.position.y - current_pose.pose.position.y\n        distance = math.sqrt(dx*dx + dy*dy)\n\n        if distance < 0.1:  # Close to goal\n            return np.array([0.0, 0.0])\n\n        # Normalize direction toward goal\n        dir_x = dx / distance\n        dir_y = dy / distance\n\n        # Calculate force (linear attraction)\n        force_magnitude = min(distance * 0.5, 2.0)  # Cap maximum force\n        return np.array([dir_x * force_magnitude, dir_y * force_magnitude])\n\n    def apply_humanoid_constraints(self, velocity):\n        # Apply humanoid-specific movement constraints\n        speed = math.sqrt(velocity[0]**2 + velocity[1]**2)\n\n        # Limit maximum speed based on humanoid capabilities\n        max_speed = 0.5  # m/s for humanoid walking\n        if speed > max_speed:\n            velocity = [v * max_speed / speed for v in velocity]\n\n        # Limit turning rate\n        if abs(velocity[1]) > 0.3:  # Sideways movement constraint\n            velocity[1] = 0.3 if velocity[1] > 0 else -0.3\n\n        return velocity\n"})}),"\n",(0,o.jsx)(n.h3,{id:"trajectory-control-for-humanoid-locomotion",children:"Trajectory Control for Humanoid Locomotion"}),"\n",(0,o.jsx)(n.p,{children:"Controlling humanoid trajectories requires special consideration:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"# Example: Humanoid trajectory controller\nfrom geometry_msgs.msg import Twist, Pose\nfrom nav_msgs.msg import Path\nimport math\n\nclass HumanoidTrajectoryController:\n    def __init__(self, node):\n        self.node = node\n        self.kp_linear = 1.5  # Proportional gain for linear velocity\n        self.ki_linear = 0.1  # Integral gain for linear velocity\n        self.kd_linear = 0.2  # Derivative gain for linear velocity\n\n        self.kp_angular = 2.0  # Proportional gain for angular velocity\n        self.ki_angular = 0.1  # Integral gain for angular velocity\n        self.kd_angular = 0.3  # Derivative gain for angular velocity\n\n        self.error_integral_linear = 0.0\n        self.prev_error_linear = 0.0\n\n        self.error_integral_angular = 0.0\n        self.prev_error_angular = 0.0\n\n        # Humanoid-specific parameters\n        self.max_linear_speed = 0.5  # m/s\n        self.max_angular_speed = 0.5  # rad/s\n        self.min_approach_dist = 0.3  # Minimum distance before slowing down\n\n    def compute_velocity_command(self, current_pose, target_pose, path_progress=0.0):\n        # Compute velocity command for humanoid navigation\n        # Calculate distance and bearing to target\n        dx = target_pose.pose.position.x - current_pose.pose.position.x\n        dy = target_pose.pose.position.y - current_pose.pose.position.y\n        distance = math.sqrt(dx*dx + dy*dy)\n\n        # Calculate desired heading\n        desired_heading = math.atan2(dy, dx)\n\n        # Get current heading from orientation\n        current_heading = self.quaternion_to_yaw(current_pose.pose.orientation)\n\n        # Calculate heading error\n        heading_error = self.normalize_angle(desired_heading - current_heading)\n\n        # PID control for linear velocity\n        linear_error = distance\n\n        # Slow down when approaching target\n        deceleration_factor = min(1.0, distance / self.min_approach_dist)\n\n        self.error_integral_linear += linear_error * 0.1  # Assuming 10Hz control\n        linear_derivative = (linear_error - self.prev_error_linear) / 0.1\n\n        linear_velocity = (\n            self.kp_linear * linear_error * deceleration_factor +\n            self.ki_linear * self.error_integral_linear +\n            self.kd_linear * linear_derivative\n        )\n\n        # Clamp linear velocity\n        linear_velocity = max(0.0, min(linear_velocity, self.max_linear_speed))\n\n        # PID control for angular velocity\n        self.error_integral_angular += heading_error * 0.1\n        angular_derivative = (heading_error - self.prev_error_angular) / 0.1\n\n        angular_velocity = (\n            self.kp_angular * heading_error +\n            self.ki_angular * self.error_integral_angular +\n            self.kd_angular * angular_derivative\n        )\n\n        # Clamp angular velocity\n        angular_velocity = max(-self.max_angular_speed, min(angular_velocity, self.max_angular_speed))\n\n        # Store current errors for next iteration\n        self.prev_error_linear = linear_error\n        self.prev_error_angular = heading_error\n\n        # Create velocity command\n        cmd_vel = Twist()\n        cmd_vel.linear.x = linear_velocity\n        cmd_vel.angular.z = angular_velocity\n\n        return cmd_vel\n\n    def quaternion_to_yaw(self, quat):\n        # Convert quaternion to yaw angle\n        siny_cosp = 2 * (quat.w * quat.z + quat.x * quat.y)\n        cosy_cosp = 1 - 2 * (quat.y * quat.y + quat.z * quat.z)\n        return math.atan2(siny_cosp, cosy_cosp)\n\n    def normalize_angle(self, angle):\n        # Normalize angle to [-pi, pi]\n        while angle > math.pi:\n            angle -= 2 * math.pi\n        while angle < -math.pi:\n            angle += 2 * math.pi\n        return angle\n"})}),"\n",(0,o.jsx)(n.h2,{id:"preparing-for-autonomous-tasks-with-safety-measures",children:"Preparing for Autonomous Tasks with Safety Measures"}),"\n",(0,o.jsx)(n.h3,{id:"humanoid-navigation-safety-framework",children:"Humanoid Navigation Safety Framework"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"# Example: Safety framework for humanoid navigation\nfrom enum import Enum\nimport threading\n\nclass SafetyLevel(Enum):\n    OPERATIONAL = 1\n    CAUTION = 2\n    WARNING = 3\n    EMERGENCY_STOP = 4\n\nclass HumanoidNavigationSafety:\n    def __init__(self, node):\n        self.node = node\n        self.safety_level = SafetyLevel.OPERATIONAL\n        self.emergency_stop_requested = False\n        self.safety_lock = threading.Lock()\n\n        # Safety parameters\n        self.critical_distance = 0.2  # Distance for emergency stop\n        self.warning_distance = 0.5   # Distance for warning\n        self.caution_distance = 1.0   # Distance for caution\n        self.max_fall_risk_tilt = 0.3 # Max tilt before fall risk\n\n    def assess_environment_safety(self, obstacles, terrain_map, robot_state):\n        # Assess safety of current environment\n        with self.safety_lock:\n            # Check for immediate collision risks\n            immediate_risks = self.check_immediate_dangers(obstacles, robot_state)\n\n            if immediate_risks:\n                self.safety_level = SafetyLevel.EMERGENCY_STOP\n                self.emergency_stop_requested = True\n                return self.safety_level\n\n            # Check for potential hazards\n            potential_hazards = self.check_potential_hazards(terrain_map, obstacles)\n\n            if potential_hazards:\n                self.safety_level = SafetyLevel.WARNING\n            elif self.is_complex_terrain(terrain_map):\n                self.safety_level = SafetyLevel.CAUTION\n            else:\n                self.safety_level = SafetyLevel.OPERATIONAL\n\n        return self.safety_level\n\n    def check_immediate_dangers(self, obstacles, robot_state):\n        # Check for immediate collision dangers\n        for obstacle in obstacles:\n            dist = self.distance_to_obstacle(obstacle, robot_state)\n            if dist < self.critical_distance:\n                return True\n        return False\n\n    def check_potential_hazards(self, terrain_map, obstacles):\n        # Check for potential navigation hazards\n        for obstacle in obstacles:\n            dist = self.distance_to_obstacle(obstacle, robot_state)\n            if dist < self.warning_distance:\n                return True\n        return False\n\n    def request_emergency_stop(self):\n        # Request immediate stop for safety\n        with self.safety_lock:\n            self.emergency_stop_requested = True\n            self.safety_level = SafetyLevel.EMERGENCY_STOP\n\n    def clear_emergency_stop(self):\n        # Clear emergency stop condition\n        with self.safety_lock:\n            self.emergency_stop_requested = False\n            # Reset to operational after assessment\n            self.safety_level = SafetyLevel.OPERATIONAL\n"})}),"\n",(0,o.jsx)(n.h3,{id:"autonomous-task-preparation",children:"Autonomous Task Preparation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'# Example: Preparing humanoid for autonomous tasks\nclass HumanoidAutonomousTaskManager:\n    def __init__(self, node):\n        self.node = node\n        self.navigation_safety = HumanoidNavigationSafety(node)\n        self.task_queue = []\n        self.current_task = None\n\n    def prepare_for_autonomous_navigation(self, goal_pose):\n        # Prepare humanoid robot for autonomous navigation task\n        self.node.get_logger().info("Preparing for autonomous navigation...")\n\n        # 1. Validate goal position\n        if not self.validate_goal_position(goal_pose):\n            self.node.get_logger().error("Invalid goal position")\n            return False\n\n        # 2. Assess current safety state\n        current_safety = self.navigation_safety.assess_environment_safety(\n            self.get_current_obstacles(),\n            self.get_current_terrain(),\n            self.get_robot_state()\n        )\n\n        if current_safety == SafetyLevel.EMERGENCY_STOP:\n            self.node.get_logger().error("Environment unsafe for navigation")\n            return False\n\n        # 3. Plan initial path\n        path = self.plan_initial_path(goal_pose)\n        if path is None:\n            self.node.get_logger().error("Could not plan initial path")\n            return False\n\n        # 4. Check path safety\n        if not self.is_path_safe(path):\n            self.node.get_logger().error("Planned path is not safe")\n            return False\n\n        # 5. Configure controllers\n        self.configure_controllers_for_humanoid()\n\n        # 6. Set up safety monitors\n        self.setup_safety_monitors()\n\n        # 7. Begin navigation\n        self.begin_navigation(goal_pose)\n\n        return True\n\n    def validate_goal_position(self, goal_pose):\n        # Validate that goal position is reachable and safe\n        # Check if goal is on traversable terrain\n        # Check if goal is within operational bounds\n        # Check if goal is not in restricted area\n        return True  # Simplified implementation\n\n    def is_path_safe(self, path):\n        # Check if the planned path is safe for humanoid navigation\n        for waypoint in path.poses:\n            # Check terrain traversability at waypoint\n            terrain_safe = self.is_terrain_safe_at(waypoint.pose.position)\n            if not terrain_safe:\n                return False\n\n            # Check for potential hazards along path\n            if self.has_hazards_near_path(waypoint.pose.position):\n                return False\n\n        return True\n\n    def setup_safety_monitors(self):\n        # Set up continuous safety monitoring during navigation\n        self.safety_timer = self.node.create_timer(\n            0.1,  # Check every 100ms\n            self.safety_monitor_callback\n        )\n\n    def safety_monitor_callback(self):\n        # Continuously monitor safety during navigation\n        current_state = self.get_robot_state()\n        obstacles = self.get_current_obstacles()\n        terrain = self.get_current_terrain()\n\n        safety_level = self.navigation_safety.assess_environment_safety(\n            obstacles, terrain, current_state\n        )\n\n        if safety_level == SafetyLevel.EMERGENCY_STOP:\n            self.execute_emergency_stop()\n        elif safety_level == SafetyLevel.WARNING:\n            self.reduce_navigation_speed()\n        elif safety_level == SafetyLevel.CAUTION:\n            self.increase_caution()\n'})}),"\n",(0,o.jsx)(n.h2,{id:"practical-exercise-complete-navigation-system",children:"Practical Exercise: Complete Navigation System"}),"\n",(0,o.jsx)(n.p,{children:"Let's create a complete example that ties all concepts together:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"# Complete example: Humanoid Navigation System\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist, PoseStamped, Point\nfrom nav_msgs.msg import Path, OccupancyGrid\nfrom sensor_msgs.msg import LaserScan, Image\nfrom nav2_msgs.action import NavigateToPose\nfrom rclpy.action import ActionClient\nfrom tf2_ros import TransformException\nfrom tf2_ros.buffer import Buffer\nfrom tf2_ros.transform_listener import TransformListener\nimport math\nimport numpy as np\n\nclass CompleteHumanoidNavigationSystem(Node):\n    def __init__(self):\n        super().__init__('complete_humanoid_navigation_system')\n\n        # Initialize components\n        self.planner = HumanoidPathPlanner(self)\n        self.controller = HumanoidTrajectoryController(self)\n        self.obstacle_avoider = HumanoidObstacleAvoider(self)\n        self.safety_manager = HumanoidNavigationSafety(self)\n        self.task_manager = HumanoidAutonomousTaskManager(self)\n\n        # TF for pose transformations\n        self.tf_buffer = Buffer()\n        self.tf_listener = TransformListener(self.tf_buffer, self)\n\n        # Publishers and subscribers\n        self.cmd_vel_pub = self.create_publisher(Twist, '/humanoid/cmd_vel', 10)\n        self.path_pub = self.create_publisher(Path, '/humanoid/current_path', 10)\n        self.scan_sub = self.create_subscription(\n            LaserScan, '/scan', self.scan_callback, 10\n        )\n        self.goal_sub = self.create_subscription(\n            PoseStamped, '/move_base_simple/goal', self.goal_callback, 10\n        )\n\n        # Navigation state\n        self.current_goal = None\n        self.navigation_active = False\n        self.current_path = None\n        self.last_command_time = self.get_clock().now()\n\n        # Control timer\n        self.control_timer = self.create_timer(0.1, self.navigation_control_loop)  # 10Hz\n\n        self.get_logger().info(\"Complete Humanoid Navigation System initialized\")\n\n    def scan_callback(self, msg):\n        # Process laser scan for obstacle detection\n        self.last_scan = msg\n        # Update obstacle avoider with new scan data\n        self.detect_obstacles_from_scan(msg)\n\n    def goal_callback(self, msg):\n        # Handle new navigation goal\n        self.get_logger().info(f\"Received navigation goal: {msg.pose.position}\")\n        self.set_navigation_goal(msg.pose)\n\n    def set_navigation_goal(self, goal_pose):\n        # Set new navigation goal and start planning\n        self.current_goal = goal_pose\n        self.navigation_active = True\n\n        # Prepare for navigation\n        success = self.task_manager.prepare_for_autonomous_navigation(goal_pose)\n        if success:\n            self.get_logger().info(\"Navigation prepared successfully\")\n        else:\n            self.get_logger().error(\"Failed to prepare for navigation\")\n            self.navigation_active = False\n\n    def navigation_control_loop(self):\n        # Main navigation control loop\n        if not self.navigation_active or self.current_goal is None:\n            return\n\n        try:\n            # Get current robot pose\n            current_pose = self.get_current_pose()\n            if current_pose is None:\n                self.get_logger().warn(\"Could not get current robot pose\")\n                return\n\n            # Check if goal reached\n            distance_to_goal = self.distance_between_poses(current_pose.pose, self.current_goal)\n            if distance_to_goal < 0.5:  # 50cm tolerance\n                self.get_logger().info(\"Goal reached!\")\n                self.navigation_active = False\n                self.current_goal = None\n                return\n\n            # Assess safety\n            obstacles = self.get_current_obstacles()\n            terrain_map = self.get_current_terrain()\n            robot_state = self.get_robot_state()\n\n            safety_level = self.safety_manager.assess_environment_safety(\n                obstacles, terrain_map, robot_state\n            )\n\n            if safety_level == self.safety_manager.SafetyLevel.EMERGENCY_STOP:\n                self.emergency_stop()\n                return\n\n            # Compute navigation command\n            cmd_vel = self.compute_navigation_command(current_pose.pose, self.current_goal)\n\n            # Publish command\n            self.cmd_vel_pub.publish(cmd_vel)\n            self.last_command_time = self.get_clock().now()\n\n        except Exception as e:\n            self.get_logger().error(f\"Error in navigation control loop: {e}\")\n\n    def compute_navigation_command(self, current_pose, goal_pose):\n        # Compute the appropriate velocity command\n        # First, try path following\n        if self.current_path and self.is_path_valid():\n            # Follow current path\n            next_waypoint = self.get_next_waypoint_along_path(current_pose)\n            if next_waypoint:\n                cmd_vel = self.controller.compute_velocity_command(\n                    current_pose, next_waypoint\n                )\n            else:\n                # Path is complete, head to goal\n                cmd_vel = self.controller.compute_velocity_command(\n                    current_pose, goal_pose\n                )\n        else:\n            # Plan new path or use direct control\n            if self.should_replan_path(current_pose, goal_pose):\n                self.current_path = self.planner.plan_path(current_pose, goal_pose)\n\n            # Use direct control toward goal\n            cmd_vel = self.controller.compute_velocity_command(\n                current_pose, goal_pose\n            )\n\n        # Apply obstacle avoidance if needed\n        if self.has_close_obstacles():\n            avoidance_cmd = self.obstacle_avoider.compute_avoidance_velocity(\n                current_pose, cmd_vel, goal_pose\n            )\n            # Blend path-following and obstacle avoidance commands\n            cmd_vel = self.blend_commands(cmd_vel, avoidance_cmd)\n\n        return cmd_vel\n\n    def get_current_pose(self):\n        # Get current robot pose from TF\n        try:\n            transform = self.tf_buffer.lookup_transform(\n                'map', 'base_link', rclpy.time.Time(), rclpy.duration.Duration(seconds=1.0)\n            )\n\n            pose_stamped = PoseStamped()\n            pose_stamped.header.frame_id = 'map'\n            pose_stamped.header.stamp = transform.header.stamp\n\n            pose_stamped.pose.position.x = transform.transform.translation.x\n            pose_stamped.pose.position.y = transform.transform.translation.y\n            pose_stamped.pose.position.z = transform.transform.translation.z\n            pose_stamped.pose.orientation = transform.transform.rotation\n\n            return pose_stamped\n        except TransformException as ex:\n            self.get_logger().error(f'Could not transform map to base_link: {ex}')\n            return None\n\n    def blend_commands(self, path_cmd, avoid_cmd):\n        # Blend path-following and obstacle avoidance commands\n        blended_cmd = Twist()\n\n        # Weight avoidance more heavily when obstacles are very close\n        avoidance_weight = self.get_obstacle_proximity_weight()\n\n        blended_cmd.linear.x = (\n            (1 - avoidance_weight) * path_cmd.linear.x +\n            avoidance_weight * avoid_cmd.linear.x\n        )\n\n        blended_cmd.angular.z = (\n            (1 - avoidance_weight) * path_cmd.angular.z +\n            avoidance_weight * avoid_cmd.angular.z\n        )\n\n        return blended_cmd\n\n    def emergency_stop(self):\n        # Execute emergency stop\n        stop_cmd = Twist()\n        self.cmd_vel_pub.publish(stop_cmd)\n        self.navigation_active = False\n        self.get_logger().warn(\"Emergency stop executed!\")\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    node = CompleteHumanoidNavigationSystem()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        node.get_logger().info(\"Shutting down navigation system...\")\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(n.p,{children:"In this chapter, you've learned how to:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Use Nav2 specifically adapted for bipedal humanoid movement patterns and constraints"}),"\n",(0,o.jsx)(n.li,{children:"Implement various motion planning algorithms suitable for humanoid robots"}),"\n",(0,o.jsx)(n.li,{children:"Apply obstacle avoidance and trajectory control techniques for safe humanoid navigation"}),"\n",(0,o.jsx)(n.li,{children:"Prepare humanoid robots for autonomous tasks with proper safety measures"}),"\n",(0,o.jsx)(n.li,{children:"Create a complete navigation system integrating all concepts"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"You now have a complete understanding of the AI-Robot Brain (NVIDIA Isaac\u2122) module, covering Isaac Sim for simulation, Isaac ROS for perception and navigation, and Nav2 for path planning. This foundation prepares you for more advanced topics in vision-language-action control in Module 4."}),"\n",(0,o.jsx)(n.h2,{id:"navigation",children:"Navigation"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Previous: ",(0,o.jsx)(n.a,{href:"./02-isaac-ros-perception-navigation",children:"Chapter 2 - Isaac ROS for Perception and Navigation"})]}),"\n",(0,o.jsxs)(n.li,{children:["Back to: ",(0,o.jsx)(n.a,{href:"../",children:"Module Overview"})]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453(e,n,a){a.d(n,{R:()=>s,x:()=>r});var t=a(6540);const o={},i=t.createContext(o);function s(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);